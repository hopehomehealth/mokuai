<?php/**CacheLock 进程锁,主要用来进行cache失效时的单进程cache获取，防止过多的SQL请求穿透到数据库用于解决PHP在并发时候的锁控制,通过文件/eaccelerator进行进程间锁定如果没有使用eaccelerator则进行进行文件锁处理，会做对应目录下产生对应粒度的锁使用了eaccelerator则在内存中处理，性能相对较高不同的锁之间并行执行，类似mysql innodb的行级锁 */class Lock_Library{    //文件锁存放路径    private $path = null;    //文件句柄    private $fp = null;    //cache key    private $name;    //是否存在eaccelerator标志    private $eAccelerator = false;    //锁定超时 秒    public  $limitTime = 30;    /**    构造函数    传入锁的存放路径，及cache key的名称，这样可以进行并发    @param string $path 锁的存放目录，以"/"结尾    @param string $name cache key    */    public function config($name,$path=''){        $path = $path ? $path : AppDir.'data/lock/';        //判断是否存在eAccelerator,这里启用了eAccelerator之后可以进行内存锁提高效率        $this->eAccelerator = function_exists("eaccelerator_lock");        if(!$this->eAccelerator)        {            $this->path = $path.$name.'.txt';        }        $this->name = $name;    }    /**    加锁    Enter description here ...    */    public function lock()    {        $startTime = time();        if(!$this->eAccelerator){            if($this->fp = fopen($this->path, 'w+')){                do{                    $canWrite = flock($this->fp,LOCK_EX|LOCK_NB);                    if(!$canWrite){                        if((time()-$startTime) > $this->limitTime){                            //超时后，自动解锁                            $canWrite = true;                            flock($this->fp, LOCK_UN);                            //echo 'lock_un ';                        }else{                            //延迟一秒内随机时间后，继续判断解锁状态                            usleep(round(rand(0,100)*1000));                            //echo 'sleep ';                        }                    }                }while(!$canWrite);            }        }else{            do{                $canWrite = eaccelerator_lock($this->name);                if(!$canWrite){                    if((time()-$startTime) > $this->limitTime){                        //超时后，自动解锁                        $canWrite = true;                        eaccelerator_unlock($this->name);                    }else{                        //延迟一秒内随机时间后，继续判断解锁状态                        usleep(round(rand(0,100)*1000));                    }                }            }while(!$canWrite);        }        return true;    }    /**    解锁    Enter description here ...    */    public function unlock()    {        if(!$this->eAccelerator)        {            if($this->fp !== false)            {                flock($this->fp, LOCK_UN);                clearstatcache();            }            //文件关闭            fclose($this->fp);        }else{            return eaccelerator_unlock($this->name);        }    }}